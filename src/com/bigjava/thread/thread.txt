一、概述
1.进程
	进程:在操作系统中独立运行的程序,每运行一个应用程序就对应着一个进程process
	多线程:在操作系统中可以同时运行多个程序
2.线程
	线程:是进程内部的一个执行单元,用来执行应用程序中一个功能thread
	多线程:在一个应用程序中可以同时执行多个功能,例如迅雷中同时执行多个下载任务就是多线程
	特性:
		1)一个进程中可以包含多个线程,且至少要有一个线程
		2)一个线程必须属于某个进程,进程是线程的容器
		3)一个进程中的多个线程共享该进程的所有资源
3.CPU时间片
	对于单核CPU,在某个时间点只能处理一个程序
	CPU分配给各个程序的时间,称为时间片,即该进程允许运行时间(时间很短)
		1)从表面上看各个程序是同时运行的,实际上CPU在同一时间只能执行一个程序
		2)只是CPU在很短的时间内,在不同程序间切换,轮流执行每个程序,执行速度很快,所以感觉上像是同时在运行
		
二、创建线程
	两种方式:
		继承Thread类
		实现Runnable接口
	
	1.继承Thread类
		步骤:
			1>定义一个类,继承自Thread类,重写run()方法
			2>创建该类的实例,即创建一个线程
			3>调用start()方法,启动线程(不能直接调用run()方法)
	2.实现Runnable接口
		步骤:
			1>定义一个类,实现Runnable接口,实现run()方法
			2>创建实现类的实例
			3>创建Thread类的一个实例,将上一步中实现类的实例传入
			4>调用start()方法,启动线程
	3.两种方式的对比
		继承Thread类
			线程执行的代码放在Thread类的子类的run方法中
			无法再继承其他类
		实现Runnable接口
			线程执行的代码放在Runnable接口实现的run方法中
			可以继承其他类,避免单继承的局限性
			适合多个相同程序代码的线程去处理同一个资源
			增强程序的健壮性

三、线程的生命周期
	1.生命周期
	2.相关方法
		start---启动线程,线程进入就绪状态(可运行状态)
		sleep---休眠线程,线程从执行状态进入阻塞状态
		yield---暂停执行线程,线程从执行状态进入就绪状态
		join---暂停执行线程,等待另一个线程执行完,线程从执行状态进入阻塞状态
		interrupt---终端线程的休眠或等待状态

四、线程安全问题
	1.简介
		多个线程同时访问共享数据时可能会出现问题,称为线程安全问题
			当多线程访问共享数据时,由于CPU的切换,导致一个线程执行了关键代码的一部分,还没执行完
			此时另一个线程参与进来,导致共享数据发生异常
		解决:线程同步机制synchronized+锁
			被synchronized包围的代码块,称为同步代码块
			被synchronized修饰的方法,称为同步方法
			锁,也称之为对象锁,每个对象都自带一个锁(标识),且不同对象的锁是不一样的
		执行过程:
			当线程执行同步代码块或者同步方法时,必须获取特定对象的锁才行
			且一旦对象的锁被获取,则该对象就不再拥有锁,直接线程执行完同步代码块或者同步方法才会释放锁
			如果线程无法获取特定对象上的锁,则线程会进入该对象的锁池中等待,直到锁被归还对象,此时需要该锁的线程进行竞争
	2.解决:
	使用同步代码块、使用同步方法	

五、线程间的通信
	1.锁池和等待池
		每个对象都自带锁池和等待锁
		锁池:
			当线程执行synchronized块时如果无法获取特定对象上的锁,此时会进入该对象的锁池
			当锁被归还给该对象时,锁池中的多个线程会竞争获取该对象的锁
			获取对象锁的线程将执行synchronized块,执行完毕后会释放锁
		等待池:
			当线程获取到对象的锁后,可以调用wait()方法放弃锁,此时会进入该对象的等待池
			当其他线程调用该对象的notify()或者notifyAll()方法,等待池中的线程会被唤醒,会进入该对象的锁池
			当线程获取对象的锁后,将从它上次调用wait()方法的位置开始继续运行
	2.相关方法
		wait---使该线程放弃对象锁,线程进入等待池-可以调用等待超时时间,超时后线程自动唤醒
		notify---随机唤醒等待池中的一个线程,线程进入锁池-唤醒的是特定对象的等待池中的线程
		notifyAll---唤醒等待池中的所有线程
			注意:
				这三个方法都只能在synchronized块中使用,即只有获取了锁的线程才能调用
				等待和唤醒必须使用的是同一个对象
				
六、生产者-消费者问题
	1.简介
		生产者-消费者问题是多线程同步的一个经典问题,即并发协作的问题
		所谓生产者-消费者问题,实际上主要是包含了两种线程:生产者线程,消费者线程
		生产者线程:
			生产商品并放入缓冲区
			当缓冲区满时,生产者不可再生产商品
		消费者线程:
			从缓冲区中取出商品
			当缓冲区为空时,消费者不可再取出商品
		注:生产者和消费者使用的是同一个缓冲区

七、线程单例
	1.简介
		为每个线程提供一个实例
			同一个线程获取的是同一个实例
			不同的线程获取的是不同的实例
		Java中提供了一个ThreadLocal,直接提供了线程单例的解决方案
			用户管理变量,提供了线程局部变量
			它为变量在每个线程中都存储了每个副本
			